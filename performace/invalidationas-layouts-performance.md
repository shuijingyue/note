Fancy animations and smooth transitions are at the core of modern mobile app design. While these things may make beautiful, transcendent experiences for your users, it's easy to forget what they might be costing you, in terms of performance. My name is Colt McCanlis. And writing performant Android applications start with the simple step of understanding what's going on in the Android system, when you update the visual properties of a view. Remember that to draw something on your device, Android generally needs to convert all that high-level XML into some that the GPU can accept and use to render to the screen. This is done with the help of an internal object called a display list. I display list basically holds all the information needed to render a view on the GPU. It contains a list of any GPU resident assets that might be needed, as well as a list of commands to execute to OpenGL, when it's time to render it. The first time a view needs to be rendered, a display list is created for it. And when we need to render that view to the screen, we execute that display list by submitting its drawing commands to the GPU. If we want to render that view again in the future, like if it's position changed on the screen, we simply need to execute that display list one extra time. However, in the future, if some visual part of the view changes, the previous display list may no longer be valid. As such, we'll need to go back, recreate the display list, and then re-execute it once again, to update the screen. But remember this. Any time the drawing content of your view changes, it will repeat this process of recreating the display list and re-executing it to the screen, the performance of which varies, depending on how complex your review actually is. And depending on the type of visual change, there's other impact on the rendering pipeline as well. For example, let's say, a text box suddenly doubles in size, causing the parent container to reposition other sibling views, before updating its own size. In this case, we've updated one view, and it cascaded to other work that needed to be done as well. These types of visual changes require additional stages of the rendering pipeline to occur. See, when the sizing of your view changes, the measure phase will be kicked off. And it will walk through your view hierarchy, asking each view what its new sizes are. And if you change the position of things, call Request Layout, or if a view group repositions its children, the layout phase will kick off, traverse the hierarchy, and figure out where everything needs to be located. And you need to be conscious that each one of these stages takes time to run. While by themselves, that may not be impactful, when there's a sudden large amount of views that get invalidated or repositioned, this can trigger a large performance drain, which means, to improve the overall performance of your rendering system minimizing invalidations in layouts is a really great place to start. Of course, you'll need some way to get more specific information about where your problems are showing up. Firstly, you can get a better sense of what part of your rendering pipeline has issues by turning on the profile GPU rendering tool on your device, which will provide you with a handy, at-a-glance view of the time it took to create, execute, and process portions of your drawing pipeline. Secondly, you can get a sense of what types of invalidations are occurring in your application, by turning on the Show GPU View Updates option. Any time and invalidation occurs in your app, you'll see invalidated part briefly flash red, which can help you understand what parts of your screen are getting invalidated, even for the simplest of actions. Thirdly, make sure you're using Hierarchy Viewer to constantly check your view hierarchy and work to keep it as flat as possible, trying to remove any redundant views. This will help reduce the overhead of the layout and measure phases when they actually occur. But this is just the beginning. For more information on reducing invalidations, flattening your hierarchy, and using hardware layers, check out the rest of the resources on the Android Performance Patterns page. And don't forget to join the Google community for more great tips and tricks. So keep calm. Profile your code. And always remember, perf matters.