[MUSIC PLAYING] COLT MCANLIS: One of the best things about writing applications using Android's Runtime is that it's a managed memory environment, which means you don't have to worry about all the extra overhead of when objects are created and destroyed. But be careful here. Even in a managed memory language, you can still end up leaking memory. My name is Colt McAnlis. And memory leaks are a common issue in complex code bases. And if not handled properly, can easily lead to some nasty performance problems in your apps. As you might recall, memory heaps in Android's Runtime are segmented into spaces based on the type of allocation and how the system can best organize those allocations for future GC events. As new objects are allocated, these characteristics are taken into account to best fit what space it should be placed into, depending on what version of Android's Runtime you are using. And here's the important part. Each space has a set size. Now, as objects are allocated, we keep track of the combined sizes. And as the space starts to grow, the system will need to execute a garbage collection event in an attempt to free up memory for future allocations. These GC events aren't generally a noticeable problem for performance. However, a lot of them, occurring over and over and over and over again, can quickly eat up your frame time. The more time you're spending doing GCs the less time you have to do other stuff like rendering or streaming audio. Now, a common issue that can cause a cascade of GC events to occur is a memory leak. Memory leaks are objects which the application is no longer using. But the garbage collector fails to recognize them as unused. The result is that they stay resident in your heap, taking up valuable space that's never freed for other objects. Now, as you start leaking more memory, the available space in your heaps space continues to get smaller. Which means that GCs will be executed more often to try to free up space for normal program execution. Which doesn't really work if large portions of your heap are never actually being freed. Finding and fixing leaks is really tricky business. Now, effectively, you have to have a clear understanding of your code and be able to validate that things work the way they should during critical actions in your code base. To confirm this type of behavior, however, requires a bit of scrutiny. Now, for example, let's say you want to ensure that when a user leaves an activity in your application, that all of the memory for that activity is properly cleaned up. How would you go about doing this? Well, firstly, you should use the Heap tool to grab a snapshot of what memory looks like while your activity is front most. And secondly, you need to create some blank activity with known or low-memory allocations that you can transition into from the activity in question. And thirdly, when you transition from one to the other, force a garbage collection event to occur. Which, if everything is destroyed properly, should remove all the activities allocations. If you see anything suspect in that second heap dump, that is memory that shouldn't actually be there, then it's a smart idea to switch over to the Allocation Tracker tool and dig a little deeper with what allocations are occurring. Using this tool, you can start tracking allocations from before the activity loads until it's unloaded and you've transitioned it back into the blank activity. The allocation tracker tool will give you a list of all objects that were created, the order in which they were created, and where they were created. So that you can track down these types of rogue allocations and figure out why they aren't being freed. Even though you're in a managed memory environment, you still have a lot of manual memory management to do yourself in order to keep your app performant. So make sure to check out the rest of the resources at Android Performance Pattern Change. And don't forget to check out the Google+ community for other great tips and tricks as well. So keep calm, 
profile your code, and always remember, perf matters. [MUSIC PLAYING]