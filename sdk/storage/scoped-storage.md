[MUSIC PLAYING] ROXANNA ALIBADI: Hi. My name is Roxanna, and I'm a product manager on the Android Framework team. And I'm joined by Zim and Yacine. So last year, we introduced a new way of thinking about storage on Android with Android 10. We call this change Scope Storage. And so today, we're going to talk more about those changes, and we're going to talk about some new things that we're thinking about to make these changes easier for developers to adopt. And at the end, Yacine is going to go through some practical examples and best practices. So first, I want to clarify what's meant by shared storage. Every app has their own private directory in internal storage. This is what you find at android/data/ your package name. And this is not visible to any other app with the storage permission. Then everything else is considered shared storage. This includes the media collections and external app directories on the SD card. We find that about half of apps today request the storage permission. But in fact, the majority of these apps don't really need such a broad view of storage. They're trying to do simple things like select an image file for a user to pick a profile picture for a social app, or maybe to download an image or a document from an email attachment. We also find that when apps have such broad writing power, they tend to leave files scattered on the disk. And when the app is uninstalled, those files are left behind, taking up space. And when so many users are suffering from low disk space, they can take all the space they can get. So we thought about how we can reimagine storage on Android so that apps can get the specific access they need without getting such a broad reading and writing power that they don't actually need. So with Scope Storage, which we introduced with Android 10, the idea is to compartmentalize storage into specified collections and to limit the access to broad storage. So as we were designing it, we thought of three basic principles that we wanted to follow. The first is better attribution. This means that the system knows which apps created which files. This helps the user better manage their storage. It also makes sure that when an app is uninstalled, all of its content is also removed unless the user explicitly wants it kept. The next is protecting app data. So as I mentioned before, internal app directories have been private. We also want to make sure that the external app directories that are created on an SD card are also not able to easily be read by other apps. And of course, we want to protect our users' data. Because when you download an image from a private message or a PDF of your tax return, you probably don't want every other app on the device with the storage permission to be able to read those files. So as we considered these principles, here are some of the key features that we added for Scope Storage in Android 10. The first is that every app has unrestricted access to their own app directories. Now, this is going to be both internal app directories and external app directories. So with Android 10, you don't need to request a storage permission to be able to write files to your own app directory on the SD card. The next is that you have unrestricted access to contribute files to media collections and to downloads. We created a new downloads collection also with Android 10. So this way, if you want to save an image, music file, video, or any other document, you can do so without any permission as long as it's saved in the organized media collections. The next change we made is that the storage permission is redefined. So instead of giving broad access to shared storage, you actually just get access to organized media collections-- the image, video, and audio collections. We also believe that app location-- or sorry-- media location metadata is private to the user or sensitive to the user. So we created a new permission called access media location that apps will need to declare if they want to see that location metadata on the image. If they don't request this, that location metadata will be stripped when the app reads the image file. So in order to read any other type of file, like a PDF or a document, apps now need to use the system picker. This is accessed using the Storage Access Framework. Also, writing any files outside of the organized media collections or your app directories also requires using the system picker. This makes sure that users can choose exactly where on the disk they want the file stored. So what happened in Android 10? We introduced Scope Storage in one of the early beta releases of Android 10, and we imposed those changes for all apps, regardless of target SDK. However, we had significant developer feedback that these changes were very dramatic and very difficult to make in such a short period of time. So we introduced a flag that you can declare in your manifest file. It's called request legacy external storage. If an app declares this flag in their manifest, then the storage permission works as it did on previous versions of Android. Despite some of the concerns that we heard, we're really happy to see that of all of the apps that are currently targeting Android 10, 98% of them don't request this flag. This shows us that the changes we introduced with Scope Storage are acceptable to most developers. However, we also understand that a lot of apps have not started targeting Android 10 yet. And we also are very conscious about the experience of these 2%, and we want to really think about how we can improve Scope Storage and add features so that these changes are easier for developers to adapt. So we're actually going to talk about some of the developer feedback that we've gotten, some of the basic themes. The first is that the changes that we introduced with Android 10 have a lack of support for using file paths or native libraries. Next, there are specific categories of apps that really need access to broad storage. For example, you can think of file managers or backup and restore apps. So these apps attempted to use the Storage Access Framework APIs to get a broad view of shared storage. However, the problem is that those APIs were not intended to be used to get access to so many nested files. So those developers reported performance issues. And also, they complained about some of the UI difficulty of having the user go and select root folders in order to get this level of storage. And also, now that we've changed the storage permission means, the definition has become muddled. So for some apps that are updated, the storage permission actually means that they're getting access to media. And for other apps that are not updated, it means they have broad access to storage. And that can be confusing. So we actually want to talk about some of the things that we're thinking about in the next release. And that's not something we normally talk about at this event, but I think it's really important to announce to developers what we're working on so that as you're making changes for Android 10, you don't make any changes that you'll need to reverse as you release the next version of Android. So the first thing is we're doing an update to the permissions UI. So we fixed the problem before where apps that are actually only getting access to media seem like they're getting access to all of shared storage. We're going to differentiate this to the user. So the user will see a different permission UI based on if that app is updated and using Scope Storage or not. And next, we're working really hard to enable file paths and native libraries for reading media. And Zim is going to talk more about that. We're also updating the APIs for modifying and deleting media files that the app didn't create itself. And that includes that we're creating a bulk option. The next big change that we're making is we're adding a special app access permission. This is specifically for apps that can demonstrate a need for broad access to shared storage and will be whitelisted by Google Play. We're also taking it a step further and protecting those external app directories and making sure that users can't select those directories with the Storage Access Framework APIs. And a big change that we're making is that we're going to be enforcing this based on target SDK. Last year, we did say that we would be enforcing this regardless of target SDK for all apps on the next release of Android. But really, we think that the best thing for the users is to introduce these changes gradually. And we also want to make sure that developers can really take the time to design their apps to make sure that they're making the changes for Scope Storage in a responsible way. Now I'll hand it over to Zim, who will talk more about the changes introduced with Android 10 and some of the new features that we're working on. ZIMUZO EZEOZUE: Thank you, Roxy. Now I'm going to dive into some more detail about the changes we launched in Android 10 as well the changes expected in the next Android release. >From the earliest versions of Android, we've always had the audio, the images, and the video collections. These collections are intended for sharing media files with other apps. In Android 10, we made a big change to allow contributing to these collections without any permissions. Likewise, you can edit and delete media files you contributed without any permissions. This was to reduce the number of apps requesting unnecessarily these storage permissions. To read media files not created by your app, you will need the read external storage permission. The write external storage permission will be deprecated in the next Android release, and requesting it will really only give you read access to media files. Editing or deleting media files not contributed by your app is just not possible without explicit user consent. This is to give users full control over when apps want to edit or delete media files, like their important pictures. In the next Android release, when you request the storage permission at runtime, users will see two different permissions strings depending on the target SDK version of your app. If you're targeting the next Android release, users will see a new media permission string requesting just access to media files in external storage. However, if you're targeting any other release, users will continue to see the old storage permission string requesting broad access to the external storage. This way, our users will understand how much access your app is requesting. So in Android 10, we launched a brand new downloads collection for sharing non-media files with other apps. Like the media collections, contributing to this collection and editing or deleting non-media files you contributed doesn't require any permissions. However, unlike the-- however, unlike the media collection, the read external storage permission does not give you any access to non-media files contributed by other apps. To gain access, you will need to launch the system picker with Storage Access Framework APIs. This will allow the user to explicitly select what files or directories you can have access to. And if the user grants you access to a file, this will be a full access. So you can read, edit, or delete media files and non-media files as you please without any additional consent. This is to give our users full control over when apps want to access non-media files that are sensitive, so for instance, their bank statements. Protecting user data is our top priority on Android, which is why in Android 10, we started restricting access to sensitive metadata contained in media files, primarily location. We can transparently strip these metadata when your app is reading media files contributed by other apps. To access this sensitive metadata, you can request the access media location permission. This permission is not user visible in the Settings UI. However, it is a runtime permission, so you have to declare it in your manifest and request it at runtime alongside the read external storage permission. Since this is a runtime permission, there is no guarantee that you will always have access to this permission even if you have the read external storage permission. This is especially true on enterprise devices where a device policy client can modify or change permissions requested by other apps. If it is absolutely important for your app that you always have the exact bytes of the file on disk, you can use the MediaStore.setRequireOriginal API. This will ensure that you always have the exact bytes of the file on disk or receive an exception if reduction would have otherwise occurred. In Android 10, we locked down file path access to the common directories. This enabled us to deliver on our privacy objectives of protecting the user. However, after going through the developer feedback, we saw that this required a lot of effort from you to adopt straight away. And in the next Android release, we will likely do this work for you. I must emphasize that all apps should still use the MediaStore whenever possible. However, we understand that there are a lot of apps dependent on libraries written in C and C++ that only accept file paths. This really is the only case where we expect you to write new code that uses file paths. A useful implementation detail that may help understand the tradeoffs between file paths and the MediaStore is that under the hood, file path requests or I/O requests using file paths are delegated to the MediaStore. You can think of the file or file path as a convenience API to the MediaStore. This means that there is some performance impact of using file paths, and there is really no feature benefits, hence our strong recommendation to use the MediaStore directly. Additionally, all the MediaStore enforcements also apply here. Media must be created in the appropriate media directories, so no music in the pictures directory, for instance. To access media files created by other apps, you will need to request the read external storage permission. Location reduction while reading media files contributed by other apps will still occur if you do not have the access media location permission granted. Also, creating non-media files must happen in the Downloads directory, so you must create non-media files like PDFs in the Downloads directory. And also, reading non-media files created by other apps will require the Storage Access Framework APIs. Files created by your app will be attributed correctly, so this will count towards your app's disk usage on the device. The team has run lots of benchmarks on sequential random read and write workloads. The conclusion here is that there is certainly some performance impact to using-- implement file path requests and delegating it to the MediaStore. However, this is negligible in most cases, especially at low I/O rates. If you really care about performance, you should measure your use cases to see how much impact file access has on your app's performance. Alternatively, you can just use the MediaStore APIs directly, and this is guaranteed to give you the best performance in all cases. And a bit more detail if you really insist on using file paths. Opens and the first reads after opening the file are fairly expensive. So if you're going to use file paths, please try to avoid opening and closing the same file multiple times. We have seen some apps in the wild doing this, and this can noticeably degrade I/O throughput and battery performance. If you are building an app that does heavy I/O-- so in the order of, say, a few hundred megabytes per second-- we would really love to hear from you, so please come say hi at the sandbox. In Android 10, we require user consent to edit or delete media not contributed by your app. To do this, you must use the MediaStore APIs to trigger a dialog to request user consent. If the user accepts, you will get a callback into your app, and you can proceed to access the file either with file paths or with the MediaStore APIs. Note that you will not get a prompt with just the file path access. So without the prior explicit user grant with the MediaStore APIs, trying to edit or delete files contributed by other apps, so media files contributed by other apps, will just fail. In the next Android release, we are improving the user consent flow for editing or deleting media introduced in Android 10. So now you can batch multiple edit [? ordered ?] requests in one dialog instead of popping one dialog per request, as it was in the case of Android 10. This should significantly improve the UX in your app and was a popular request in the last release. And we are very thrilled to deliver this to you. You always have the option to copy files to your Apps directory in external storage and edit the copy, but we would only recommend this for one-off edits and small-sized files since we do not want to clutter our user's disk, and the copied file will count against the app's disk usage. Now I will hand back to Roxy to talk about more storage changes in the next Android release. ROXANNA ALIBADI: Thanks, Zim. So as we mentioned, in order to read, edit, or delete files that were not created by your app that aren't media files, you're going to need to use the Storage Access Framework APIs. So the way-- so Storage Access Framework APIs have-- we saw were used by some apps that wanted to get broad access to shared storage. And as I mentioned, that's not the intent of those APIs. So in order to prevent this, we made some changes to the UX when the intent ACTION_OPEN_DOCUMENT_TREE is launched. So ACTION_OPEN_DOCUMENT_TREE is an intent specifically for an app to request an entire directory that it wants read and write access to. In the next version of Android, apps will not be able to ask the user to select the root, anything under android/data, or the Downloads directory. Apps can still select individual files from the Downloads directory. It just can't select the entire directory. We're also adding special app access for apps that can truly demonstrate a need for broad access to shared storage. There are a limited number of use cases that we believe can demonstrate this need. A couple examples that we know of are File Manager and backup and restore apps. Only apps that can prove this need will be granted this access. In order to demonstrate it, you'll need to submit a declaration form to Google Play, to the Google Play Developer Console. And only if whitelisted will your app be able to be submitted, and then you can ask the user for this special app access. If you are whitelisted and the user grants your app this access, you'll get an unfiltered view of MediaStore. That includes non-media files. However, these apps will not get access to external app directories. This is, like we mentioned before, which we believe that these directories should be more protected. I want to emphasize that this access will not be granted for apps that simply want to create their own file picking experience. Those apps should use the system picker. Now, we created the request legacy storage-- request external legacy storage flag in Android 10 as a response to developer feedback for apps that need more time to adapt to Scope Storage. However, in future versions of Android, this flag will no longer be available. So only apps that have the special app access will be able to get a broad view of shared storage. I also hope that we've demonstrated in this talk that we're really responsive to developer feedback on this topic. So I really encourage you, even though we're not enforcing this until the future version of Android, that you try out all the Scope Storage changes and you let us know about use cases that you feel are not supported and should be. I also want to remind developers that as you move to target Android 10, if you have any files that are in shared storage, like PDFs or media files that are outside the organized directories, you'll need to move them into your app storage. Otherwise, if you target Android 10, you will lose access to these files. So now let's recap some of the features of Scope Storage in Android 10 and some of the new features that we've talked about. First, media can be contributed without permission now. Also, non-media files can be contributed to the Downloads directory. However, non-media files reading those files will require using the system picker and the Storage Access Framework APIs. Apps now need to request permission to see location metadata, images, and videos, access media location. In the next version of Android, we'll be introducing file path access for reading media. In the next version, we'll be updating the Media Modification APIs, including a bulk option. And we'll be restricting the Storage Access Framework so that users cannot select specific-- directories will give broad access to shared storage or sensitive directories. And there will be a special app access for select use cases whitelisted by Google Play. And all this will be enforced by target SDK. Now I'll had it over to Yacine, who will go through some practical examples. YACINE REZGUI: Thanks, Roxy. So as Roxy and Zim mentioned, we're simplifying the developer experience on Scope Storage. But with all these APIs, it may not be easy to figure out which one you should use in your application. So let me sum up all of that with [? a ?] [? sample ?] that you can have an idea of what to use. Imagine a media player app. It needs to get all the videos on the phone device and be able to display and play them whenever the user wants it. For this, we will use the MediaStore API. The advantage of it is to have all the files indexed so it helps in terms of performance of discoverability. We can get the files through the ContentResolver API, and we can use advance query parameters like size, duration, or resolution. Finally, because we're accessing files created by other applications, we need to add the read external storage permission in our manifest. So the MediaStore API is a contract between the media provider and the application that use it. We queried through the ContentResolver, which has a similar API to an SQL query. We choose the data we want with a projection, filter it with some selected arguments, and order it based on the selected columns. For our query, in this case, we want to have the ID column, the display name, duration, and size. Those columns are part of the MediaStore video columns contract. You can have the full list on the website on our web documentation. So for our selections argument, we want to filter on videos equal to five minutes or longer. And as the Duration column is in milliseconds, we need to convert it to the right unit. We attach all of those elements to our query with the right MediaStore video content URI. We also want to order it by the duration. The query returns us a cursor to go through all the results. We need to-- sorry. My bad. We need to get each column's index to be able to get the content. If the column doesn't exist, we get an exception. We're caching the indexes here to avoid having to fetch for each result for each row. We loop through our cursor and get data for each column based on its [? size. ?] Since we're accessing the external content URI, from the MediaStore video collection, we need to use the base URI and append the ID of the video at the end of it. That will get our content URI, and we can use it. Finally, we get all the data, we can add to our list and display it to the user. Now for our second use case, let's imagine a photo feature app. You can create images as well as editing or deleting images created by other applications. For this, we will use again the MediaStore API. Because, as mentioned, we're possibly editing images from other applications, we will need the READ_EXTERNAL_STORAGE permission. Whenever we'll edit or delete an image, the OS will prompt a dialog to the user to get that content. >From the next Android release, you will be able to bulk all of those requests within a single dialog. Lastly, if you want to provide an enhanced experience based on the location of where the photos were taken, you need to add the access media allocation to be able to get all the EXIF data of any file. Remember that you have to double check if you still have access to this media location. You should not assume having it all the time. To be able to prompt the dialog to the user, we need first to append the file descriptor on the write mode, which at the first time, initially, it will throw us an exception, a recoverable security exception. Within that exception data, there is a pending intent that we need to send to the system to be able to get the dialog. Once the user [? counts and ?] given, we can open again the file descriptor and have finally access to it. Now let's imagine another use case, a productivity application, something like email, for example. We may want to write an email and attach a file to it, any type of it. It can be a PDF, a ZIP file, or something else. For this, we will use the Storage Access Framework. Whenever you need it, you don't actually have to ask for permission. You can use any files available on the user device as well as using content from other content providers like Google Drive. Locally or remotely, the API is abstracting all the complexity for you, so you just consume it in the same way, whether it's on the device or remotely. The UI is handled by an intent. So here we need to use a specific intent to be able to have the file picker. To select a file, we need to use the ACTION_OPEN_DOCUMENT intent. And to select a folder, we need to use ACTION_OPEN_DOCUMENT_TREE. The access on the file is not granted all the time. Until the user reboot, you still have access to it. If you want to persist it, you need to use takePersistableUriPermission method. With it, you will have always access to that file. But you also need to check that this file hasn't been deleted in the meantime. Inside our productivity app, the first thing we will do is to use that ACTION_OPEN_DOCUMENT. In this case, we will set the category to category openable, which means we will get the openable entities-- it means the files-- to avoid not having the calendar of contact entries, for example. We set the write [? main ?] type. In this case, we just want to have the application PDF, which means the PDFs. At this point, we can render the PDF, for example, in our draft email just to show a preview to the user using PDF Render API, for example. And lastly, we can just send the email, and having our whole experience. A second example within our Gmail app is the ability to save any attached files to an email wherever the user want on device. For this, we will use ACTION_CREATE_DOCUMENT intent. It has similar parameters to the previous action we just created with an extra one here, extra title where we can put a default finding. The user can still change that within the file saver UI. Lastly, we can open the file descriptor on it and just edit it on the write mode and add the content there. We want our ecosystem of applications to thrive with a privacy first approach. If you provide backup of file management features, you can get an unfiltered view of the MediaStore API. It requires a special access permission which needs to be approved in the Play Console like SMS and core permissions. We're here to help you getting ready for Scope Storage. If you have any questions, come to talk to us at our sandbox booth. We will have the experts answering all your questions. But among our recommendations, one of them is do not use hardcoded path. The path may change between different versions, or the dile may be deleted or moved to a different folder. You should not assume having that. The main thing we advise you to use is to mix the content URI with appended ID in the same way I presented earlier. You can check out all our code sample on our GitHub, which highlights all the possible use cases with scope storage. And you can already test Android 10 SDK by targeting it on Android Studio. We shaped the features on Score Storage based on your feedback. If you have a specific use case that our API is not covering yet, please find a bug or an issue on our bug tracker to help us making a better Scope Storage for you. If you have any questions, again, come to our sandbox booth. It's an opportunity for you to have access to so many engineers from the product team. Also, to understand more of your own usage of Score Storage and trying to understand how can we shape better the API, please fill the survey line available there. You can take pictures. I will wait a quick moment there. I want to see phones. Thank you, everyone. [MUSIC PLAYING]