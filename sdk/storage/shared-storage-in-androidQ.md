[MUSIC PLAYING] SEB GRUBB: Firstly, we will clarify what is meant by shared storage-- also known as external storage. Shared storage is the area of apps-- can write files visible to other apps, once they get granted the reader right external storage permission. Functions that return locations within shared storage include-- getExternalFilesDirs, which returns your apps files folder; getExternalCachedDirs, which returns your apps cache file folders; and get ExternalMediaDirs, that returns your apps media folders. Game developers may also be interested in the OBB directories returned by getOBBDirs. Now, let's dive down into what the stored situation is like currently on Android Pi. On one hand, we have internal storage, which is private to your app-- meaning, other apps will never be able to access data there. Internal storage is thus a good place for internal app data that the user doesn't need to directly access. And on the other hand, we have shared storage that we just talked about. It is a world-readable space that can be viewed and modified by the user and apps. This is what you see when you enable USB mass storage and plug your phone into a computer. To see files in shared storage or /SD card, apps need the storage permission. For files written there, there is no App-to-File attribution. There's only one exception. Shared storage contains app-attributed directories that do not need any permission to be accessed by the owner app. These include the directories returned by the GetExternalFiles media and CachedDirs functions. No permissions are needed, since these folders have a clear app to follow ownership structure. This ownership structure ensures that the files are cleaned on app uninstall. So that was the situation in Android Pi. Storage is one of the most popular permissions used by Android apps. And as a result, we've seen apps behind in all kind of ways, resulting in issues such as this clutter. In Android Q, we looked at how we could improve shared storage by abiding to three principles that improve the experience for users. The first one is better attribution. Here, we're really trying to solve clutter by avoiding files lingering around on disk once an app is uninstalled. So in Q, when shown, the system knows what files belong to what apps. This makes it easier for users to manage their files. And it means that, when the app is uninstalled. The Content [INAUDIBLE] disk is cleaned up after. There's obviously always content that user will want to possess post uninstall. And we'll talk about this later. The second principle is protecting app data. When apps write files to external storage, it should not be made freely available and visible to other apps. You don't want other apps looking into what your app is doing. So in Q, we're protecting the app-specific data by disallowing other apps to view this content. And the third principle is protecting user data. When you download files, such as pictures in your private conversations or PDF of your bank statements, you probably don't want all apps to immediately see these files and glean info about your behavior. In Q, we're making sure users know when and what files apps are accessing. So sticking to these principles means that we are doing deep changes in the ways storage works in Android. And we understand, it may take some time for apps to adapt to these changes. But we think that, in the long-term, this will help make Android a better platform for users by providing better privacy and storage management. So with this in mind, let's have a look at how storage will work in Android Q. So in Android Q, we're doubling down on MediaStore. The first change is that apps can contribute to MediaStore without any permission. However, to view content contributed by other apps, the Storage permission is required. Apps can continue to read and write to their app-specific directories. But other apps, even if they have obtained storage permission, cannot view them, unless the files are attributed to them. Apps will still be able to pick files present anywhere on disk, using the system picker, which gives the app and user a transactional approach to gain access to a file. This makes access more secure, since it makes it more explicit to the user what file or files are being accessed. The final thing to mention is the way that internal storage is not changing in Q. So MediaStore is not new to Android. In fact, it's been here since day one. But Android Q-- we're doubling down on MediaStore and improving it. So let's look more into how it works. So first question is-- what belongs in MediaStore? MediaStore is designed to hold content that belongs to the user and that is available to other apps. Thus, we recommend only contributing files when the user actively expects it to be present and the MediaStore collections, such as explicitly taking a picture in the Camera app. The main types of media present in MediaStore are audio, video, and images. So content contributed to MediaStore persists post app uninstall. However, once the app is uninstalled. The content is considered to be orphaned. And if the same app is then reinstalled later, it will need to obtain the storage permission from the user to see content it had previously contributed. Now, what doesn't belong in MediaStore? This is a bit more nuanced, since this is more that user expectations. But sometimes, it's pretty obvious what doesn't belong. App-specific media-- like thumbnails, album art, or stickers-- would usually not be appropriate for MediaStore, since they are not files a user would want to see in other apps or see persist post app's uninstall. In some cases, you may not be sure where the content belongs. For example, users in chat apps may exchange a large amount of pictures that would create clutter in MediaStore. In these situations, we suggest not contributing to MediaStore straight away. But wait until a user has taken an explicit action, such as selecting Save. Now, in Android Q, we're introducing a new collection in MediaStore, which is the downloads collections. And this one works a bit differently than the previous three that we mentioned. This collection is to place files that don't fit into other collections, such as PDF files or any other type of documents. You can also contribute content there that would go into other collections, if you want it to be explicitly part of a downloads collection. In that case, they will also be automatic contributed to the other appropriate collections. So for example, if you download a photo on your web browser and add it to the Downloads collection, it will also be added to the Images collection. So like the previous mentioned collections, apps can view all the content they contributed. However, to view files contributed by other apps, a system picker-- invoked by Action Open Document, for example-- is required to be used. Another tip is not always contribute data to a downloads collection, especially when the user might want to control the way it's stored, such as saving a document. In this case, launching Action Create Document Intent is recommended. It lets users choose any local network or cloud storage provider location. So this was a quick overview how MediaStore works. And I'm going to hand you over to Jeff, who'll give you more details of how to contribute and query MediaStore. Thanks, Jeff. JEFF SHARKEY: Thanks. Thanks, Seb. [APPLAUSE] So as Seb mentioned, one of the big changes that we're making in the Q release is we're giving you developers the opportunity to contribute items to MediaStore without needing the storage permission. You can now insert, modify, and delete any content that you own yourselves into MediaStore. Only when you want to work with content that has been contributed by other applications do you need the storage runtime permission. We think this is going to be a great change for apps like photo or camera apps, because you don't need the storage permission anymore. You can capture that image and then save it into MediaStore. And you won't need that runtime permission. As Seb also mentioned-- things that you contribute to these common collections, it's your way of saying, this content belongs to the user. And it's intended to persist beyond the lifetime of your application. So if the user uninstalls your app, that data is going to be preserved. So let's take a look at an example of how this works in practice with some code. As Seb mentioned, MediaStore has been around since Android 1.0. So some of the APIs that you're seeing on screen-- you've already been working with today. I'll focus on a handful of places we've added new special behaviors that can help make it a better experience. So here, the code sample on the slide-- we're creating a ContentValues to contribute a new image that we're working with. In the Q release, all we need to do is specify the display name and the MIME type of the content we're working with. In this case, it's just a JPEG image. The new thing that's highlighted on screen here-- this is a new feature in the Q release-- the Is Pending flag. When you insert an item-- like, when you inserted item that is marked as pending, by default, it will be hidden from other applications on the device. When they go query MediaStore, they're not going to see that item that's pending. This gives you, as the developer, a way to temporarily work on that item until you're ready to reveal it to other apps on the device. An example here might be if you're a web browser working on a long-running download, where you may switch between mobile and Wi-Fi networks. You can insert that downloaded item, mark it as pending. You can slowly work-- maybe over 15 to 20 minutes-- however long it takes to download that item. And once you're finished, that's when you can set that Is Pending bit back to 0 to reveal it to other applications on the device. So back to our example here-- we have our content values inserting something that's pending. I don't believe we have our content resolver. And we're going to be working with the primary external storage volume. Content resolver.insert-- you've probably already been using that today. This is what's going to insert a record to say that you want to work on this item. It's reserving a space for you to insert. Now, that we have that item, the result of that Insert call was a new specific URI that has been allocated just for you to work on that item. With that item URI, you can now open a file descriptor-- in this case, for write access here. And you can stream contents into place. So we've highlighted some of the details here. If you need to, you can also do that up in managed code in Java. You can also use that file descriptor to go across JNI and contribute data, if you have native code in your application. At some point, we'll be finished with the file descriptor. We'll close it. And now it's time to reveal that to the other apps on the device. And that's as simple as clearly not that ContentValues, setting that Is Pending bit to 0, and then calling Content resolver.update. Once you make this call, that's going to cause it to become visible to the other apps on the device. So that was a simple example. Let's look at some more complex ways-- some new features that we've given to you to work with in MediaStore. You now have the ability to influence directories of where things are stored on these external storage devices. In the simple example that we just looked at a few moments ago, the operating system automatically picks a safe default location. Because we were inserting an image/JPEG object, the OS will put it in the Pictures directory by default. Similarly, if we were inserting-- say-- an audio type of file format, we would automatically insert it into the Music directory on the device. So we're helping set some good defaults. But you also have the ability to influence if you want a specific directory. And this is the new Relative Path column, which is part of the public API. You can set this value to control where those files are placed on disk. We'll give an example of that in just a moment. Similar to these two columns, both the Relative Path and the Display Name-- you can use them when you're inserting content. But you can also use them later on. Once you've published content, if you need to move it around on disk, you can call Content resolver.update with those columns. And the OS will now move the content on disk on your behalf. So zooming out a little bit more-- we've talked about influencing directories of where the content lands. In Q, we've also given you more capabilities to control which storage device it lands on. This is particularly useful for Android devices have that have multiple shared storage locations. They may have a built-in shared storage. But they also may have an SD card slot, where the user has inserted something. Starting in Q, you now have the flexibility to control which device you want that content to land on. Earlier we mentioned the Volume External Primary. That's the volume name of that primary storage device. You can also call a new API, Get External Volume Names. And this will enumerate all of the possible storage locations that are available for your application to use. Once you've selected one of those volume names, it's easy to start working with that collection, using the various Get content URI methods that you'll find across the collections in MediaStore. So if we pick a secondary storage device-- if we discover it-- we can go past that as the argument to the Get content URI-- say, for example-- for the Images collection. That will allow us to work with images that are present on that secondary storage device, such as an SD card. So let's take a look at an example of both of these advanced concepts together in one example. So the first thing we talked about was that Relative path-- being able to influence where things land on disk. Here, we have a simple music file that we're inserting-- MySong.mp3. The relative path here-- we're asking for it to be placed under Music, My Artist, My Album. Something worth noticing-- to call back to Seb's point that he made earlier-- one of our goals in Q is to help ensure that the user's content is organized on their device. And so what this means-- that top-level directory-- we're going to help make sure that it's placed in a reasonable location. So here, we're inserting an MP3 file-- an audio file-- into the Music directory-- the top-level directory. The OS is going to allow this, because the content type makes sense. If, for example, we were trying to insert this MP3 file into the user's Pictures collection, that doesn't make sense. That's disorganized. And so the OS would throw an exception back to you. So just those three common collection types that we discussed-- Audio, Video, and Images-- there's a handful of locations-- top-level directories-- that are allowed for each of those. You can find, in the developer documentation, more details. But it's our way of helping keep the user's content organized. All right-- so in this example, that relative path-- we've selected Music, My Artist, My Album. Just like we did before, we're going to use Insert. But the second half of the slide-- this is where we're going to select a specific secondary storage device. We're seeing what volume names are available. And the ellipses there-- it's up to you and your application. But you could go and prompt the user to select one of those storage devices that are available. Or you could have settings deep inside of your application where you let the user pivot and choose one of those storage devices. Either way, when you've made your selection, here's where you pass that volume name into the Get Content URI. And this is what's going to allow us to work with the audio collection on a specific storage device. And then the final call will actually insert that and work with it. So we talked quite a bit about contributing content. Let's shift gears and talk about discovery-- if you'd like to consume the content or list it or display it to the user. Thankfully, the APIs you've been working with today-- content resolver.query-- those will continue to work with these collection types. So you can query-- find items in the user's Images or Music collection. The one thing we're changing in the Q release-- we're strongly recommending that you switch to using content resolver.openfile descriptor when you want to work with one of those particular items. And the reason is, the data column, which has been there for many years, has now been deprecated. And we'll get into a little bit more later today on why that's deprecated. But the best practice that we're encouraging developers to move towards is using Open File descriptor instead. You'll get back a partial file descriptor, be able to send that either to managed or down to native code. So it's quite flexible. As we mentioned earlier, by default, applications that query this collection won't see any pending items that other applications are still working on. If users expect to see those pending items in your application, you can still modify the URI that you're about to query to request that those pending items be included. One thing to note is that, for each of the items that is being contributed, we now track who contributed it-- who the owner is of those items. What this means is-- while an item is pending, only the owner of that item can work with the content. They're the only ones that can read or write the contents of the file. Only when they've published it, when you've cleared that pending flag, is it available for other applications to see. The reason that's relevant here for the set Include Pending-- you'll be able to see that other people are about to contribute items. You won't be able to open those items until they've been published, because they're still under construction. Here's an example of how to use these things in practice. So here, we have a normal collection-- the users Video collection. We've gotten our Get Content URI from that. But in our case, we'd like to see some of that pending content. The set Include Pending-- we pass in the URI. And we get back a slightly modified version of that URI. It's modified to tell us, as the OS, that you'd also like to see the pending items. Once you've run a query with a cursor that comes back, that gives it the opportunity to show those items to the user and pick one to work with. Open File Descriptor is another great choice here for a specific item that you've found. With that partial file descriptor that comes back-- many of our utilities across the US, whether it's Image Decoder or other media player APIs-- they're ready and willing to accept that partial file descriptor. Finally, one side note at the bottom of the slide-- there's a new API in Q-- content resolver.loadThumbnail. And this is designed to provide an optimized path for loading a small lightweight thumbnail in your app. You can imagine, if you're scrolling through a large list of contents, you don't want to open the large heavyweight items just to generate a small thumbnail to show to the user. So this new Load Thumbnail API-- for a specific item, you pass in the item you're interested in and the size-- roughly, the dimensions on-screen that you're looking to show to the user. Internally, in the OS, we'll do the hard work of helping resize that image to make it nice and lightweight. And we'll also handle caching that, so that we ensure that it's fast for you to reopen in the future. And we'll also handle-- if the content has changed over time, we'll automatically invalidate that thumbnail and regenerate it. So it's designed as a great best practice API to use, if you want to just show lightweight thumbnails. So now that we've discovered items, let's talk about editing items. A change that we're making in the Q release-- we've already described items that you contribute. You have full read, write, and delete access to the items that you have contributed. However, items that belong to other applications, you'll only have read access to. If you'd like to be able to modify or write those items, you'll need to involve the user. And we're doing this-- any of the operations on Content Resolver that work with modifying files, whether it's Update, Delete, or opening a file descriptor for the right mode-- all of those-- they will check internally if you have the right permission to that item. If you don't have the permission, it'll throw back a new type of exception-- a Recoverable Security Exception. We'll dig into, in a moment, an example of what this looks like. The easiest thing-- when you receive one of these, it's telling you, it's an exception. You don't have access now. But if you involve the user, the user is able to grant you that access so that you can have both read and write access. Let's take a look at an example. Here at the top, we're attempting to delete a specific photo. But we don't have to know ahead of time if we have that permission or not. If we have the permission to delete, we'll succeed. If we don't, it'll throw that recoverable security exception back at us. And it's up to us to involve the user in whatever way is most appropriate. In this example on the code slide, we're going to be showing an alert dialog to the user in our application. This alert dialog-- when the user presses the button, we're going to launch that PendingIntent that's included in that exception, which is going to show a dialog to the user, letting them grant that access to your application for that specific item that you're interested in. So we get that exception. There's a nice message. Under User Action, it has a title. And there's also that pending intent. That action item or that action intent is a pending intent that you can send to involve the user. The alert dialog is just one example here for the purposes of our presentation today. But depending on the design of your application, you may also want to show a notification to the user if you're trying to do this in the background. There's many ways to get the user to launch the pending intent. So it's quite flexible in letting you figure out the best way to involve the user. So shifting gears a little bit more-- one thing we're focusing on in Q is helping protect location metadata. As Seb mentioned, one of the critical features we're building in Q is helping protect users' privacy and security. And what this means is-- normally, when you go interact with an image file, we'll be redacting any location information included, such as the latitude or longitude, in the EXIF metadata. So if users expect to see the location information inside of your app, you can add a new permission-- Access Media Location-- to your manifest. When you open that file, we will not redact the information. It will allow you to see the full latitude longitude. But what we're doing-- it's by default. We're protecting that information. You'll still be able to see the other EXIF metadata, such as the shutter length, shutter speed, other information about the date-time taken. But only the location data is going to be redacted. On MediaStore, there are two columns, Latitude and Longitude, that in previous releases have been indexed. Now, in the Q release, you'll find that those columns are null. And they're empty. Instead, if you need access to the location metadata, you can use the EXIF interface tool instead. Let's take a look at this in action. So in this case, if your app actually needs access to that location information-- if the user expects it-- you would just add a user's permission tag to your manifest. Note that this is not a runtime permission. It's purely a signal to us on the OS that you're interested in this information. Simply by adding it, it will grant you that access. So by virtue of requesting that permission, when you go to open-- in this case-- the openInputStream for a particular photo, you can pass that into the EXIF interface. That's a class that's been in the OS for a couple of years. But it's also available in the jetpack support libraries. That will help decode that information in the metadata and give you access to that latitude and longitude information to help you build your app. So we've talked so far about the three important principles that we've been building into Q-- helping protect user's data, helping protect your data, and giving better accountability to the user over who's responsible for putting that data on the device. In order to deliver on those goals, starting in Q, we have to start restricting the direct raw access to the underlying file system. And we're doing this using a feature we're calling Scoped Storage. Let's dig a little bit more into what that means. This has changed over the course of our beta releases this year-- Beta 1, Beta 2, and also in Beta 3. What we're going to be talking about today is the final design that we're going to be shipping in the Q release. So in the Q release, if your app is targeting an older API level, below or before Q, you will see no changes. You will continue to retain full access to the shared storage device-- that raw kernel file system level access. However, once your application targets Q, it's put into this Scoped mode. And what this means-- it no longer has direct raw file system access to the SD card. One note is-- you will continue to receive these package-specific directories. You'll continue to have raw direct access to those directories. These are the ones that Seb mentioned at the very beginning of the presentation-- those best-practice APIs-- so context.GetEsternalFilesDirs, CachedDirs, MediaDirs, and ObbDirs. All of those directories-- because they have your package name in them, you'll continue to enjoy full raw system access to those. It's only outside of those locations that the kernel will start returning either a File Not Found exception, if you're running managed code, or an EPERM error not, if you're running down a native code. Instead, if you'd like to interact with content outside of those package-specific directories, we're encouraging you to use MediaStore or the Storage Access Framework instead. Let's take a look at example-- so when is it appropriate to use one versus the other? We've talked about both interchangeably. MediaStore is good for those strongly-typed content that we talked about-- images, video, and audio. But it's not a good fit for other content types, like Word documents, Excel documents, or PDF files. Instead, we want you to launch an intent, like the Storage Access Framework, to let the user pick exactly what content you work with. These intents have been around since the Kit Kat release. You can call them using Action Open Document or Action Create Document. And these have two benefits for you as developers. One is it's a whole lot less code for you to build and maintain. Instead of building your own file-picking experience that the user has to learn when they come into your application, they're now presented with a single uniform experience across all apps when they want to pick content to work with. So right-- to contrast, MediaStore is a good fit for those well-defined collections-- Images, Video, and Audio. But also, MediaStore is limited to only work with local content that is built into the device. It doesn't offer any access to other storage locations off the device. That's another powerful feature of the Storage Access Framework. It gives the user the ability to choose to work with a network file share, such as in a small business environment, or a cloud storage provider. This is an open platform. So starting in Kit Kat, there was the Document Provider API. If you find yourself-- if you'd like to provide a place to store content, you, as a third-party developer, can go build one of these document providers and appear in the list, right next to any of the other storage locations that are available to the user. So we think it's quite powerful and flexible. So we've also heard, loud and clear from you, as our developer community, when we started initiating these changes, that taking away that access required a lot of changes on your part. And this is why, as we announced a couple weeks ago in a blog post, we've relaxed. We've relaxed the requirements for the Q release. So Scope storage-- when you target Q, you have the opportunity to temporarily opt out. In our testing internally, the majority of applications, when we enabled Scope storage, we found that they worked. There's only a small handful of cases, where applications may not be following our best practices, that we found there were bugs. So we hope that, as you target the Q release, you'll attempt to keep Scope storage enabled. And we hope that you'll be able to find that it just works. If you don't-- if you encounter bugs, we'd like to ask you to do two things. First, you can use this Manifest flag to temporarily opt out. And second-- please, reach out to us and our developer advocates so we can understand more about your use case and make sure that we can work together to solve it. The one final thing that we want to make really clear is that this is only temporary. This Manifest flag will not work in next year's major platform release. And part of that is our goal of trying to deliver on that full message of delivering the user privacy and security. So thank you for your help with that. Let's take a look at an example of how you would use this. A note is that some of these names have changed over time between the beta releases. What we're looking at on the slides today are the final attribute and method names that will ship in the final Q release. The names are going to be slightly different in the Beta 3 release that was just launched yesterday. So here, we're targeting the Q release. And using this Manifest flag, we can temporarily opt out. We can say, we'd like to go back to the old storage world. You can add this. One example that we've heard from developers is-- maybe you're embedding a shared library from another developer that you don't have the ability to quickly change. It's code that you don't own. This might be a good reason to add this flag temporarily. But please, reach out to us and that library developer to see if we can work together to migrate towards best practices. The second code snippet on the slide here is-- we recognize that your app may be running under either of these modes. It may be in the Legacy mode or in the new Scoped mode. And the method here on Environment lets you check to see which of those modes your application is running under. One thing that's worth noting is that, on Android, we always preserve the original level of access you had when your application was first installed. So if you were installed on a P device, where you expected to have full access to the storage device, your app will continue to have that, even after the user upgrades to the Q device or after they've upgraded your app. So you'll preserve that. You'll have that access you've always had-- that [INAUDIBLE] when you were first installed. This method is the good way to check to see which of those states that you're running under. So thank you for taking the time to understand more of our motivation about why we are making some of these changes. We understand they're hard. And hopefully, we can work together to be able to help improve the privacy and security of our users together. Both Seb and I will be at the Sandbox tomorrow at 1:30 PM, if you have any additional questions for us. With that-- thank you for your time. [MUSIC PLAYING]